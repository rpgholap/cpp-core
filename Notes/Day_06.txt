DAY 6 – C++ NOTES

------------------------------------------------------------
CONST MEMBER FUNCTION
------------------------------------------------------------
A member function declared with `const` ensures:
- It cannot modify any data member  
- It can only read values  
- this pointer becomes → const Student *const this  

Used mostly in:
• Getter functions  
• Print functions  

Syntax:
int getRollNo() const {
    return rollNo;  // OK
}

Invalid:
void printRecord() const {
    rollNo = 20;   // ERROR – cannot modify data
}

Notes:
• const functions cannot modify members  
• const member function changes type of this pointer  
• Used when function is only for reading  

------------------------------------------------------------
MUTABLE MEMBER
------------------------------------------------------------
Allows modifying a variable even inside a const function.

Why?
Used for:
- Logging  
- Caching  
- Counters  

Syntax:
mutable int attendanceCount = 0;

In const function:
attendanceCount++;  // allowed

Notes:
• mutable bypasses const restrictions  
• mutable works only on non-static members  

------------------------------------------------------------
FUNCTION CHAINING USING *this
------------------------------------------------------------
Returning `*this` enables calling multiple functions in a chain.

Example:
obj.joined().camera_on().print();

Both functions must return:
const ClassName&

Notes:
• *this used for chaining  
• return type must be reference to same class  

------------------------------------------------------------
TYPEDEF FOR CLASSES
------------------------------------------------------------
typedef class StudentAttendanceReport { ... } SAR;

Now `SAR` becomes alias for the class.

Note:
• typedef creates a new type name  

------------------------------------------------------------
AGGREGATE INITIALIZATION 
------------------------------------------------------------
Used to initialize objects directly without constructors.

Rules:
1. Members must be public  
2. No user-defined constructors (pre-C++11 restriction)  
3. No private/protected members  
4. No virtual functions  
5. No custom destructor  

Examples:
Student s1{100, "Shil"};  
Student s2{145, "Shubham", {1, "PG-DAC"}};

Array of objects:
Student arr[] = { {100,"A"}, {101,"B"} };

C++20 – Designated initialization:
Student s3{ .rollNo=123, .name="Aditya" };

Notes:
• Aggregate objects must have public data members  
• No constructor → aggregate  
• C++20 supports designated initializers  

------------------------------------------------------------
AGGREGATE INITIALIZATION + INHERITANCE
------------------------------------------------------------
Earlier: inheritance blocked aggregate initialization.  
C++11/14/17 improved support.  
C++20 → Braces elision allowed.

Example:
class B : A {
public:
    int y;
    B(int x, int y) : A{x}, y{y} {}
};

B b{10, 20};   // C++20

Notes:
• C++20 allows aggregate initialization for inheritance  

------------------------------------------------------------
ARRAYS OF OBJECTS
------------------------------------------------------------
Used to store objects of same class in an array.

Stack allocation:
Student s_arr[3];

Heap allocation:
Student* s_arr = new Student[3];

Access:
s_arr[i].acceptRecord();

Notes:
• Array of objects can be on stack or heap  
• Access using dot operator (.)  

------------------------------------------------------------
DESTRUCTOR (VERY IMPORTANT)
------------------------------------------------------------
Destructor:
- Called automatically  
- Used to release heap memory  
- No return type  
- No parameters  
- Cannot be overloaded  
- Only one destructor allowed  

Syntax:
~Student() {
    cout << "Destructor called!";
}

Called when:
• Object goes out of scope (stack)  
• delete or delete[] used (heap)  

Notes:
• Destructor frees memory  
• Cannot be overloaded  
• For array delete[] must be used  

------------------------------------------------------------
FILE HANDLING (C++)
------------------------------------------------------------
Header:
#include <fstream>

Classes:
• ifstream → read  
• ofstream → write  
• fstream → read + write  

Functions:
open(), close(), getline()

Writing file:
ofstream out("demo.txt");
out << "Hello";

Reading file:
string line;
while(getline(in, line)) { cout << line; }

Notes:
• getline used for reading lines  
• ofstream is for writing  

------------------------------------------------------------
USER-DEFINED STRING CLASS
------------------------------------------------------------
Implements:
- Dynamic memory allocation  
- Constructor  
- Destructor  
- Copy constructor  
- print() and accept()

Important:
char* str;  
int len;

setString() handles allocation + copy.

Destructor:
~String() { delete[] str; }

Notes:
• Destructor required for releasing char*  
• Using new[] requires delete[]  

------------------------------------------------------------
SHALLOW COPY vs DEEP COPY
------------------------------------------------------------

SHALLOW COPY:
- Copies pointer address  
- Both objects share same memory  
- Dangerous (double free possible)  

DEEP COPY:
- Allocates new memory  
- Copies full string value separately  
- Safe  

Default copy constructor → shallow copy  
User-defined copy constructor → deep copy

Note:
• Deep copy needed when class manages dynamic memory  

------------------------------------------------------------
COPY CONSTRUCTOR + RULE OF 3
------------------------------------------------------------
Copy constructor called when:
• Passing object by value  
• Returning object by value  
• Creating new object from existing

Rule of 3:
If you define ANY of these manually:
1. Destructor  
2. Copy constructor  
3. Copy assignment operator  

Then you MUST define all 3.

Notes:
• Rule of 3 prevents memory leaks  
• Copy constructor must take reference  
• Copy assignment is different from copy constructor  

------------------------------------------------------------
SUMMARY
------------------------------------------------------------
• const function cannot modify members  
• mutable allows modification inside const function  
• Aggregate initialization requires public members  
• delete[] required for array of objects  
• ofstream writes, ifstream reads  
• Default copy constructor does shallow copy  
• Deep copy needed for dynamic memory (char*)  
• Rule of 3: destructor + copy ctor + assignment operator  
