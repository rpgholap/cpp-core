DAY 5 – C++ NOTES

------------------------------------------------------------
THIS POINTER (FINAL PART)
------------------------------------------------------------
`this` → pointer to the current calling object.

Not available in:
static member functions  
Because static functions do not belong to any object.

Use cases:
- Resolve naming conflicts  
- Return *this for function chaining  
- Pass current object to another function  

Example:
Student& setRollNo(int rollNo){
    this->rollNo = rollNo;
    return *this; // enables chaining
}

Notes:
• this pointer holds address of current object  
• static functions cannot use this pointer  
• Function chaining requires returning *this  

------------------------------------------------------------
INITIALIZATION vs ASSIGNMENT
------------------------------------------------------------
Initialization → value assigned at creation  
Assignment → value assigned after creation  

int val = 10;         // Initialization  
int val2; val2 = 20;  // Assignment  

Constructor performs initialization  
Setter performs assignment  

Notes:
• Initialization happens only once  
• Assignment can happen anytime  
• Constructors handle initialization  

------------------------------------------------------------
REFERENCE VARIABLES
------------------------------------------------------------
Reference = alias name (nickname) for original variable.

Properties:
- Must be initialized at declaration  
- Cannot be null  
- Cannot be reseated (cannot refer to another variable later)  
- No extra memory created  
- Used for call-by-reference  

Syntax:
int a = 10;
int &ref = a;

Notes:
• Reference cannot be null  
• Reference must be initialized immediately  
• Reference is not a pointer  

------------------------------------------------------------
CALL BY VALUE / ADDRESS / REFERENCE
------------------------------------------------------------

CALL BY VALUE:
• Copy passed  
• Changes do NOT affect original  
• Safe but slower for large data  

CALL BY REFERENCE:
• Function gets alias of variable  
• Changes affect original  
• Best for performance  

CALL BY ADDRESS:
• Pointer passed  
• Changes affect original  
• Suitable for dynamic memory / arrays  

Notes:
• Call by value cannot modify original  
• Call by reference uses &ref  
• Call by address uses pointer  

------------------------------------------------------------
POINTER vs REFERENCE 
------------------------------------------------------------
REFERENCE:
• No null  
• No separate memory  
• Must initialize  
• Easy syntax  

POINTER:
• Can be null  
• Has its own memory  
• Can change address  
• More flexible but complex  

Note:
• Pointer has independent memory, reference does not  

------------------------------------------------------------
DYNAMIC MEMORY (new/delete)
------------------------------------------------------------
Stack → fixed size  
Heap → flexible, dynamic memory  

new → allocates memory + calls constructor  
delete → frees memory + calls destructor  

malloc → C function (no constructor)  
free → C function  

Notes:
• new returns typed pointer  
• malloc returns void*  
• delete calls destructor, free does not  

------------------------------------------------------------
TYPES OF CONSTRUCTORS 
------------------------------------------------------------

1. DEFAULT CONSTRUCTOR  
• No parameters  
• Initializes default values  

2. PARAMETERIZED CONSTRUCTOR  
• Takes arguments  
• Can be overloaded  

3. COPY CONSTRUCTOR  
• Creates new object from existing object  
• Takes reference of same class  
Syntax:
Student(const Student &s)

Note:
If user writes parameterized constructor → must write default constructor manually  

4️. MOVE CONSTRUCTOR  
• Introduced in C++11  
• Takes rvalue reference (&&)  
• Moves resources instead of copying  
• Improves performance  

5. DELEGATE CONSTRUCTOR  
• One constructor calls another  
Syntax:
Student() : Student(10) { }

Notes:
• Copy constructor takes reference  
• Move constructor takes rvalue reference  
• Delegating constructor reduces code duplication  

------------------------------------------------------------
CONSTRUCTOR INITIALIZER LIST
------------------------------------------------------------
Used to initialize data members **before** constructor body executes.

Syntax:
Student(int r, string n) : rollNo(r), name(n) { }

Required when:
- const data members  
- reference data members  
- better performance  

Execution Order:
1. Memory allocation  
2. Initializer list  
3. Constructor body  
4. Object ready  
5. Destructor  

Notes:
• const members must be initialized in initializer list  
• Initializer list runs before constructor body  

------------------------------------------------------------
CONST DATA MEMBER
------------------------------------------------------------
const variable MUST be initialized using initializer list.

class Student {
    const int rollNo;
public:
    Student(int r) : rollNo(r) {}
};

Notes:
• const member cannot be modified  
• const member requires initializer list  

------------------------------------------------------------
SUMMARY: 
------------------------------------------------------------
• this pointer unavailable in static functions  
• Initialization ≠ assignment  
• Reference must be initialized immediately  
• Call by reference modifies original  
• new/delete are C++ memory operators  
• malloc/free are C functions  
• Copy constructor uses const reference  
• Move constructor uses rvalue reference  
• Delegating constructor calls another constructor  
• Const members must be initialized using initializer list  

